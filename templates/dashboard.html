{% extends "base.html" %}

{% block head %}
<style>
    .dashboard-container {
        width: 100vw;
        height: 100vh;
        background: var(--primary);
        color: var(--secondary);
        overflow: hidden;
        position: relative;
    }
    
    .dashboard-header {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
    }
    
    .dashboard-title {
        font-size: 2rem;
        margin-bottom: 0.5rem;
        color: var(--accent);
    }
    
    .dashboard-subtitle {
        font-size: 1rem;
        opacity: 0.7;
    }
    
    .dashboard-description {
        font-size: 0.8rem;
        opacity: 0.6;
        margin-top: 0.5rem;
        font-style: italic;
    }
    
    .viz-container {
        width: 100%;
        height: 100%;
        position: relative;
    }
    
    .mode-toggle {
        position: absolute;
        top: 80px;
        right: 20px;
        z-index: 100;
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 8px;
        border-radius: 4px;
    }
    
    .mode-btn {
        background: none;
        border: 1px solid var(--accent);
        color: var(--accent);
        padding: 8px 16px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .mode-btn.active {
        background: var(--accent);
        color: var(--primary);
    }
    
    .mode-btn:hover {
        background: var(--accent);
        color: var(--primary);
    }
    
    #wordcloud {
        width: 100%;
        height: 100%;
    }
    
    .stats-overlay {
        position: absolute;
        bottom: 20px;
        left: 20px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.7;
    }
    
    .live-indicator {
        position: absolute;
        top: 80px;
        left: 20px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        opacity: 0.8;
    }
    
    .live-dot {
        width: 8px;
        height: 8px;
        background: var(--accent);
        border-radius: 50%;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    .word-node {
        position: absolute;
        color: var(--secondary);
        font-size: 16px;
        transition: all 0.5s ease;
        cursor: pointer;
        user-select: none;
    }
    
    .word-node:hover {
        color: var(--accent);
        transform: scale(1.2);
    }
    
    .connection-line {
        position: absolute;
        height: 1px;
        background: rgba(0, 255, 136, 0.2);
        transform-origin: left center;
        transition: opacity 0.5s ease;
    }
    
    .floating-word {
        pointer-events: none;
        will-change: transform, left;
    }
    
    .network-node {
        cursor: pointer;
        will-change: transform;
    }
    
    .network-link {
        pointer-events: none;
        will-change: opacity;
    }
</style>
{% endblock %}

{% block content %}
<div class="dashboard-container">
    <div class="dashboard-header">
        <h1 class="dashboard-title glitch">COLLECTIVE MIND</h1>
        <p class="dashboard-subtitle mono">Live visualization of participant thoughts</p>
        <p class="dashboard-description">Words and connections emerge from visitor reflections across all projects</p>
    </div>
    
    <div class="live-indicator">
        <div class="live-dot"></div>
        <span class="mono">LIVE</span>
    </div>
    
    <div class="mode-toggle">
        <button class="mode-btn active" onclick="setMode('wordcloud')">Words</button>
        <button class="mode-btn" onclick="setMode('network')">Network</button>
        <button class="mode-btn" onclick="setMode('flow')">Flow</button>
    </div>
    
    <div class="viz-container">
        <div id="wordcloud"></div>
    </div>
    
    <div class="stats-overlay">
        <div>Thoughts collected: <span id="thoughtCount">0</span></div>
        <div>Active connections: <span id="connectionCount">0</span></div>
        <div>Last update: <span id="lastUpdate">--:--</span></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    let currentMode = 'wordcloud';
    let wordData = {};
    let thoughtCount = 0;
    
    // Initialize visualization
    initDashboard();
    
    function initDashboard() {
        loadWordcloud();
        
        // Listen for real-time updates
        socket.on('new_feedback', function(data) {
            thoughtCount++;
            document.getElementById('thoughtCount').textContent = thoughtCount;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            
            // Add new words to visualization
            addNewWords(data);
        });
        
        // Refresh data every 30 seconds
        setInterval(loadWordcloud, 30000);
    }
    
    function loadWordcloud() {
        fetch('/api/wordcloud')
            .then(response => response.json())
            .then(data => {
                wordData = data;
                thoughtCount = Object.values(data).reduce((a, b) => a + b, 0);
                document.getElementById('thoughtCount').textContent = thoughtCount;
                
                document.getElementById('wordcloud').innerHTML = '';
                
                if (currentMode === 'wordcloud') {
                    renderWordcloud();
                } else if (currentMode === 'network') {
                    renderNetwork();
                } else if (currentMode === 'flow') {
                    const container = document.getElementById('wordcloud');
                    container.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); font-size: 24px; font-style: italic;">Awaiting new thoughts...</div>';
                }
            });
    }
    
    function setMode(mode) {
        currentMode = mode;
        
        // Update button states
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');
        
        // Clear and render new visualization
        document.getElementById('wordcloud').innerHTML = '';
        
        if (mode === 'wordcloud') {
            renderWordcloud();
        } else if (mode === 'network') {
            renderNetwork();
        } else if (mode === 'flow') {
            const container = document.getElementById('wordcloud');
            container.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); font-size: 24px; font-style: italic;">Awaiting new thoughts...</div>';
        }
    }
    
    function renderWordcloud() {
        const container = document.getElementById('wordcloud');
        const words = Object.entries(wordData);
        
        if (words.length === 0) return;
        
        const maxFreq = Math.max(...Object.values(wordData));
        
        words.forEach(([word, freq]) => {
            const wordEl = document.createElement('div');
            wordEl.className = 'word-node';
            wordEl.textContent = word;
            
            const size = 12 + (freq / maxFreq) * 48;
            const x = Math.random() * (window.innerWidth - 200);
            const y = Math.random() * (window.innerHeight - 100) + 100;
            
            wordEl.style.cssText = `
                left: ${x}px;
                top: ${y}px;
                font-size: ${size}px;
                opacity: ${0.3 + (freq / maxFreq) * 0.7};
            `;
            
            container.appendChild(wordEl);
            
            // Animate in
            setTimeout(() => {
                wordEl.style.transform = 'scale(1)';
            }, Math.random() * 1000);
        });
    }
    
    function renderNetwork() {
        const container = document.getElementById('wordcloud');
        
        // Fetch NLP-based network data
        fetch('/api/word_network')
            .then(response => response.json())
            .then(networkData => {
                if (networkData.nodes.length === 0) {
                    container.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); font-size: 24px;">Collecting thoughts...</div>';
                    return;
                }
                
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const maxSize = Math.max(...networkData.nodes.map(n => n.size));
                
                // Position nodes in a force-directed layout simulation
                const nodes = networkData.nodes.map((node, i) => {
                    const angle = (i / networkData.nodes.length) * 2 * Math.PI;
                    const radius = 150 + (node.size / maxSize) * 200;
                    return {
                        ...node,
                        x: centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 100,
                        y: centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 100
                    };
                });
                
                // Create nodes
                nodes.forEach(node => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'word-node network-node';
                    nodeEl.textContent = node.id;
                    nodeEl.style.cssText = `
                        left: ${node.x - node.id.length * 4}px;
                        top: ${node.y - 10}px;
                        font-size: ${node.size}px;
                        opacity: ${0.7 + (node.frequency * 0.3)};
                        color: ${node.frequency > 0.5 ? 'var(--accent)' : 'var(--secondary)'};
                        font-weight: ${node.frequency > 0.3 ? 'bold' : 'normal'};
                        text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
                        transition: all 0.3s ease;
                    `;
                    
                    nodeEl.addEventListener('mouseenter', () => {
                        nodeEl.style.transform = 'scale(1.3)';
                        nodeEl.style.color = 'var(--accent)';
                        // Highlight connected links
                        container.querySelectorAll('.network-link').forEach(link => {
                            if (link.dataset.source === node.id || link.dataset.target === node.id) {
                                link.style.opacity = '0.8';
                                link.style.background = 'var(--accent)';
                            }
                        });
                    });
                    
                    nodeEl.addEventListener('mouseleave', () => {
                        nodeEl.style.transform = 'scale(1)';
                        nodeEl.style.color = node.frequency > 0.5 ? 'var(--accent)' : 'var(--secondary)';
                        container.querySelectorAll('.network-link').forEach(link => {
                            link.style.opacity = link.dataset.strength;
                            link.style.background = 'rgba(0, 255, 136, 0.2)';
                        });
                    });
                    
                    container.appendChild(nodeEl);
                });
                
                // Create links
                networkData.links.forEach(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    
                    if (sourceNode && targetNode) {
                        const linkEl = document.createElement('div');
                        linkEl.className = 'connection-line network-link';
                        linkEl.dataset.source = link.source;
                        linkEl.dataset.target = link.target;
                        linkEl.dataset.strength = link.strength;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        
                        linkEl.style.cssText = `
                            left: ${sourceNode.x}px;
                            top: ${sourceNode.y}px;
                            width: ${length}px;
                            height: ${2 + link.strength * 3}px;
                            transform: rotate(${angle}rad);
                            opacity: ${link.strength};
                            background: rgba(0, 255, 136, 0.2);
                            transition: all 0.3s ease;
                        `;
                        
                        container.appendChild(linkEl);
                    }
                });
                
                document.getElementById('connectionCount').textContent = networkData.links.length;
                
                // Add pulsing animation to the network
                setInterval(() => {
                    const links = container.querySelectorAll('.network-link');
                    links.forEach(link => {
                        const currentOpacity = parseFloat(link.style.opacity);
                        link.style.opacity = currentOpacity * (0.8 + Math.random() * 0.4);
                        setTimeout(() => {
                            link.style.opacity = currentOpacity;
                        }, 500);
                    });
                }, 3000);
            })
            .catch(error => {
                console.error('Network error:', error);
                container.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); font-size: 18px;">Network visualization loading...</div>';
            });
    }
    
    function addNewWords(data) {
        const container = document.getElementById('wordcloud');
        
        if (currentMode === 'flow' && data.keywords && data.keywords.length > 0) {
            container.innerHTML = ''; // Clear waiting message
            const keywords = data.keywords;

            keywords.forEach((word, index) => {
                const wordEl = document.createElement('div');
                wordEl.className = 'word-node';
                wordEl.textContent = word;
                
                // Start from random positions, invisible
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                
                wordEl.style.cssText = `
                    position: absolute;
                    left: ${startX}px;
                    top: ${startY}px;
                    font-size: ${24 + Math.random() * 24}px;
                    color: var(--secondary);
                    opacity: 0;
                    transition: all 1.5s cubic-bezier(0.23, 1, 0.32, 1);
                    transform: scale(0.5);
                    font-weight: bold;
                    text-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
                `;
                container.appendChild(wordEl);

                // Animate in to form a poetic phrase
                setTimeout(() => {
                    const targetX = window.innerWidth / 2 + (index - keywords.length / 2) * 120 + (Math.random() - 0.5) * 50;
                    const targetY = window.innerHeight / 2 + (Math.random() - 0.5) * 80;
                    wordEl.style.opacity = '1';
                    wordEl.style.transform = 'scale(1)';
                    wordEl.style.left = `${targetX}px`;
                    wordEl.style.top = `${targetY}px`;
                }, 100 + index * 150);

                // Hold, then animate out
                setTimeout(() => {
                    wordEl.style.opacity = '0';
                    wordEl.style.transform = 'scale(0.2) rotate(' + (Math.random() * 40 - 20) + 'deg)';
                }, 6000 + index * 100);

                // Remove from DOM and restore waiting message
                setTimeout(() => {
                    wordEl.remove();
                    if (index === keywords.length - 1) {
                         container.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--muted); font-size: 24px; font-style: italic;">Awaiting new thoughts...</div>';
                    }
                }, 8000);
            });

        } else if (currentMode === 'network') {
            // Add pulsing effect to existing network on new feedback
            const existingWords = container.querySelectorAll('.word-node');
            existingWords.forEach(wordEl => {
                wordEl.style.animation = 'pulse 1s ease-in-out';
                setTimeout(() => {
                    wordEl.style.animation = '';
                }, 1000);
            });
        }
    }
</script>
{% endblock %}
